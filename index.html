<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Семейное древо</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        window.SUPABASE_URL = window.SUPABASE_URL || '';
        window.SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || '';
        window.SUPABASE_BUCKET = window.SUPABASE_BUCKET || 'person-media';
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-0: #0b1020;
            --bg-1: #101a3a;

            --panel-border: rgba(255, 255, 255, .10);

            --text: #e7eaf3;
            --muted: rgba(231, 234, 243, .72);

            --card: #ffffff;
            --card-text: #0f172a;
            --card-muted: #64748b;

            --male: #2563eb;
            --female: #ef4444;
            --unknown: #94a3b8;

            --link: rgba(226, 232, 240, .26);
            --link-strong: rgba(226, 232, 240, .38);

            --shadow: 0 14px 30px rgba(0, 0, 0, .22);

            --ring: #fb7185;

            --dim: 0.18;
            --dimLinks: 0.12;

            --branch-color: rgba(56, 189, 248, .85);

            --panel-w: 360px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background:
                radial-gradient(1200px 700px at 20% 20%, rgba(99, 102, 241, .20), transparent 60%),
                radial-gradient(1000px 700px at 80% 30%, rgba(34, 211, 238, .16), transparent 55%),
                radial-gradient(900px 700px at 60% 90%, rgba(244, 63, 94, .10), transparent 55%),
                linear-gradient(160deg, var(--bg-1), var(--bg-0));
            color: var(--text);
        }

        .app-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column
        }

        .app-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, .55);
            border-bottom: 1px solid var(--panel-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }

        .admin-bar {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 8px 16px 10px;
            background: rgba(15, 23, 42, 0.65);
            border-bottom: 1px solid var(--panel-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 9;
        }

        .admin-bar.active {
            display: flex;
        }

        .admin-bar label {
            font-size: 12px;
            font-weight: 600;
            color: rgba(231, 234, 243, 0.8);
        }

        .admin-bar input[type="file"] {
            font-size: 12px;
            color: rgba(231, 234, 243, 0.9);
        }

        .admin-bar .admin-btn {
            padding: 6px 10px;
            font-size: 12px;
        }

        .admin-bar .admin-btn.secondary {
            background: rgba(231, 234, 243, 0.12);
            color: #e2e8f0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .logo i {
            width: 34px;
            height: 34px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .10);
            color: #a5b4fc;
            font-size: 16px;
        }

        .logo h1 {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: .2px
        }

        .logo .sub {
            margin-left: 10px;
            font-size: 12px;
            color: var(--muted);
            font-weight: 500;
            display: none;
        }

        @media(min-width:980px) {
            .logo .sub {
                display: inline
            }
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .ctrl-btn {
            width: 40px;
            height: 40px;
            border-radius: 14px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .10);
            color: var(--text);
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0, 0, 0, .12);
            transition: transform .12s ease, background .12s ease, border-color .12s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ctrl-btn:hover {
            background: rgba(255, 255, 255, .12);
            border-color: rgba(255, 255, 255, .16);
            transform: translateY(-1px);
        }

        .ctrl-btn.admin-active {
            background: rgba(251, 113, 133, .2);
            border-color: rgba(251, 113, 133, .45);
            color: #fecdd3;
        }

        .ctrl-btn:active {
            transform: translateY(0px) scale(.98);
        }

        .main-content {
            flex: 1;
            position: relative
        }

        #tree {
            width: 100%;
            height: 100%
        }

        .link {
            fill: none;
            stroke: var(--link);
            stroke-width: 1.6;
            stroke-linecap: round;
        }

        .node {
            cursor: default
        }

        .card-shadow {
            filter: drop-shadow(0 12px 20px rgba(0, 0, 0, .18));
        }

        .person-outer {
            fill: var(--card);
            stroke-width: 1.6;
            transition: transform .12s ease, filter .12s ease, stroke-width .12s ease, opacity .15s ease;
        }

        .person-outer.m {
            stroke: color-mix(in srgb, var(--male) 65%, white)
        }

        .person-outer.f {
            stroke: color-mix(in srgb, var(--female) 65%, white)
        }

        .person-outer.u {
            stroke: rgba(148, 163, 184, .9)
        }

        .node:hover .person-outer {
            filter: drop-shadow(0 14px 22px rgba(0, 0, 0, .22));
            transform: translateY(-1px);
        }

        .node.selected .person-outer {
            stroke: #f59e0b !important;
            stroke-width: 3 !important;
        }

        .dimmed {
            opacity: var(--dim);
        }

        .dimmed-link {
            opacity: var(--dimLinks);
        }

        .in-branch .person-outer {
            filter: drop-shadow(0 18px 26px color-mix(in srgb, var(--branch-color) 35%, transparent));
        }

        .in-branch-link {
            stroke: var(--branch-color) !important;
            opacity: .78 !important;
            stroke-width: 2.1 !important;
        }

        /* ===== INFO PANEL (desktop: right) ===== */
        .info-panel {
            position: fixed;
            top: 76px;
            right: 0;
            width: var(--panel-w);
            height: calc(100vh - 132px);
            transform: translateX(100%);
            /* <-- теперь скрывается полностью */
            transition: transform .28s ease;
            z-index: 100;
            will-change: transform;
            pointer-events: auto;
            overflow: visible;
        }

        .info-panel.open {
            transform: translateX(0)
        }

        /* Внутренняя “поверхность” */
        .info-surface {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, .92);
            color: #0f172a;
            border-radius: 18px 0 0 18px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(15, 23, 42, .06);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            overflow: hidden;
        }

        .info-header {
            background: rgba(15, 23, 42, .92);
            color: #fff;
            padding: 12px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .info-header-title {
            font-weight: 800;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .toggle-btn {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(255, 255, 255, .10);
            border: 1px solid rgba(255, 255, 255, .12);
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 0 0 auto;
        }

        .info-content {
            padding: 14px 14px 18px;
            overflow: auto;
            height: calc(100% - 52px);
            font-size: 13px;
            line-height: 1.45;
        }

        .admin-section {
            border-top: 1px solid rgba(15, 23, 42, 0.12);
            margin-top: 12px;
            padding-top: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .admin-card {
            background: rgba(15, 23, 42, 0.04);
            border-radius: 14px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .admin-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .admin-row label {
            font-size: 12px;
            font-weight: 600;
            color: rgba(15, 23, 42, 0.72);
        }

        .admin-row input,
        .admin-row select {
            border-radius: 10px;
            border: 1px solid rgba(15, 23, 42, 0.12);
            padding: 8px 10px;
            font-size: 14px;
            font-family: inherit;
            color: #0f172a;
            background: #fff;
        }

        .admin-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .admin-btn {
            border: none;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            color: #fff;
            background: linear-gradient(135deg, #2563eb, #7c3aed);
            box-shadow: 0 6px 14px rgba(37, 99, 235, 0.18);
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        .admin-btn.secondary {
            background: rgba(15, 23, 42, 0.1);
            color: #0f172a;
            box-shadow: none;
        }

        .admin-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(37, 99, 235, 0.24);
        }

        .admin-note {
            font-size: 12px;
            color: rgba(15, 23, 42, 0.6);
        }

        .admin-modal {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 40;
        }

        .admin-modal.open {
            opacity: 1;
            pointer-events: auto;
        }

        .admin-dialog {
            background: #fff;
            color: #0f172a;
            width: min(92vw, 420px);
            border-radius: 18px;
            padding: 20px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .admin-dialog h2 {
            font-size: 18px;
        }

        .admin-error {
            color: #dc2626;
            font-size: 12px;
            min-height: 16px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 7px 10px;
            border-radius: 999px;
            background: rgba(15, 23, 42, .05);
            border: 1px solid rgba(15, 23, 42, .08);
            font-size: 12px;
            color: rgba(15, 23, 42, .78);
            margin-top: 10px;
        }

        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(86px, 1fr));
            gap: 10px;
        }

        .media-card {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(15, 23, 42, 0.08);
            background: rgba(15, 23, 42, 0.04);
        }

        .media-card img,
        .media-card video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .media-remove {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 26px;
            height: 26px;
            border: none;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.85);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(15, 23, 42, 0.2);
        }

        .media-remove i {
            font-size: 12px;
        }

        .media-empty {
            font-size: 11px;
            color: rgba(15, 23, 42, 0.5);
            text-align: center;
            padding: 10px;
            border-radius: 14px;
            border: 1px dashed rgba(15, 23, 42, 0.18);
            background: rgba(15, 23, 42, 0.02);
        }

        .rich-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .rich-toolbar button {
            border: 1px solid rgba(15, 23, 42, 0.12);
            background: #fff;
            border-radius: 8px;
            font-size: 12px;
            padding: 6px 8px;
            cursor: pointer;
        }

        .rich-editor {
            min-height: 120px;
            border-radius: 12px;
            border: 1px solid rgba(15, 23, 42, 0.12);
            padding: 10px;
            background: #fff;
        }

        .section {
            margin-top: 14px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 900;
            color: rgba(15, 23, 42, .72);
            text-transform: uppercase;
            letter-spacing: .6px;
            margin-bottom: 8px;
        }

        .list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .list-item {
            padding: 10px 10px;
            border-radius: 14px;
            background: rgba(15, 23, 42, .045);
            border: 1px solid rgba(15, 23, 42, .08);
            cursor: pointer;
            transition: transform .12s ease, background .12s ease, border-color .12s ease;
        }

        .list-item:hover {
            background: rgba(15, 23, 42, .06);
            border-color: rgba(15, 23, 42, .10);
            transform: translateY(-1px);
        }

        .li-name {
            font-weight: 800;
            font-size: 13px;
            color: rgba(15, 23, 42, .90);
        }

        .li-meta {
            font-size: 12px;
            color: rgba(15, 23, 42, .60);
            margin-top: 4px;
        }

        /* ===== DESKTOP TAB (отдельно от панели!) ===== */
        .info-tab {
            position: fixed;
            right: 0;
            top: 190px;
            width: 58px;
            height: 320px;
            z-index: 101;
            /* чуть выше панели */
            cursor: pointer;
            user-select: none;

            border-radius: 18px 0 0 18px;
            border: 1px solid rgba(255, 255, 255, .12);
            border-right: none;

            background:
                linear-gradient(180deg, rgba(255, 255, 255, .10), rgba(255, 255, 255, .04)),
                rgba(15, 23, 42, .70);

            box-shadow: 0 16px 34px rgba(0, 0, 0, .22);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);

            display: flex;
            align-items: center;
            justify-content: center;

            transition: transform .28s ease, background .18s ease;
        }

        .info-tab.open {
            transform: translateX(calc(-1 * var(--panel-w)));
        }

        .info-tab:hover {
            background:
                linear-gradient(180deg, rgba(255, 255, 255, .14), rgba(255, 255, 255, .06)),
                rgba(15, 23, 42, .72);
        }

        .info-tab-inner {
            width: 100%;
            height: 100%;
            position: relative;
            padding: 10px 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .info-tab-arrow {
            width: 36px;
            height: 36px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, .10);
            border: 1px solid rgba(255, 255, 255, .12);
            color: #fff;
            font-size: 15px;
            flex: 0 0 auto;
            box-shadow: 0 10px 18px rgba(0, 0, 0, .16);
        }

        /* аккуратная вертикальная подпись */
        .info-tab-label {
            width: 100%;
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            overflow: hidden;
            padding: 4px 2px;
        }

        .vword {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .vchar {
            font-weight: 800;
            letter-spacing: .2px;
            font-size: 12px;
            line-height: 12px;
            color: rgba(255, 255, 255, .94);
            text-shadow: 0 1px 0 rgba(0, 0, 0, .22);
        }

        .vchar.muted {
            font-weight: 700;
            opacity: .82;
        }

        /* ===== Portrait/bottom-sheet ===== */
        @media (max-aspect-ratio: 1/1) {
            :root {
                --panel-w: 100vw;
                --sheet-peek: 56px;
                /* будет синхронизироваться JS-ом */
                --sheet-half: 56vh;
                /* будет синхронизироваться JS-ом */
            }

            .info-tab {
                display: none;
            }

            /* ===== Mobile bottom-sheet (app-like) ===== */
            .sheet-scrim {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, .35);
                opacity: 0;
                pointer-events: none;
                transition: opacity .18s ease;
                z-index: 95;
            }

            .sheet-scrim.show {
                opacity: 1;
                pointer-events: auto;
            }

            .info-panel {
                top: auto;
                right: auto;
                left: 0;
                bottom: 0;
                width: 100%;
                height: min(78vh, 620px);
                border-radius: 18px 18px 0 0;
                /* default collapsed */
                transform: translateY(calc(100% - var(--sheet-peek)));
            }

            /* state-driven transforms */
            .info-panel[data-state="collapsed"] {
                transform: translateY(calc(100% - var(--sheet-peek)));
            }

            .info-panel[data-state="half"] {
                transform: translateY(calc(100% - var(--sheet-half)));
            }

            /* drag support */
            .info-panel.dragging {
                transition: none !important;
            }

            .info-header {
                touch-action: none;
                /* allow vertical drag */
            }

            /* В collapsed показываем только header (убираем белую полоску) */
            .info-panel[data-state="collapsed"] .info-content {
                display: none;
            }

            .info-surface {
                border-radius: 18px 18px 0 0;
            }

            .info-header {
                cursor: pointer;
                padding: 12px 14px 10px;
            }

            /* grab handle */
            .info-header::before {
                content: "";
                width: 46px;
                height: 4px;
                border-radius: 4px;
                background: rgba(255, 255, 255, .35);
                display: block;
                margin: 2px auto 10px;
            }

            .info-header-title {
                font-size: 15px;
                text-align: center;
                width: 100%;
            }

            /* toggle button on mobile is optional; keep but smaller */
            .toggle-btn {
                border-radius: 14px;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">

        <header class="app-header">
            <div class="logo">
                <i class="fa-solid fa-tree"></i>
                <h1>Семейное древо <span class="sub">— интерактивная генеалогия</span></h1>
            </div>

            <div class="controls">
                <button id="zoom-in" class="ctrl-btn" title="Увеличить"><i class="fa-solid fa-plus"></i></button>
                <button id="zoom-out" class="ctrl-btn" title="Уменьшить"><i class="fa-solid fa-minus"></i></button>
                <button id="reset-view" class="ctrl-btn" title="Сброс"><i
                        class="fa-solid fa-arrows-rotate"></i></button>
                <button id="admin-toggle" class="ctrl-btn" title="Войти как администратор"><i
                        class="fa-solid fa-user-shield"></i></button>
            </div>
        </header>
        <div id="admin-bar" class="admin-bar">
            <label for="admin-upload-ged">GEDCOM файл</label>
            <input id="admin-upload-ged" type="file" accept=".ged,.GED,text/plain" />
            <button class="admin-btn" type="button" id="admin-save-ged">Сохранить</button>
            <button class="admin-btn secondary" type="button" id="admin-export-ged">Скачать GED</button>
            <button class="admin-btn secondary" type="button" id="admin-reset-ged">Сбросить к опубликованным</button>
        </div>

        <div class="main-content">
            <div id="tree"></div>
        </div>

        <!-- TAB ВНЕ панели (важно!) -->
        <div id="info-tab" class="info-tab" title="Информация">
            <div class="info-tab-inner">
                <div id="info-tab-arrow" class="info-tab-arrow"><i class="fa-solid fa-arrow-left"></i></div>
                <div id="info-tab-label" class="info-tab-label"></div>
            </div>
        </div>

        <div id="sheet-scrim" class="sheet-scrim"></div>

        <div id="info-panel" class="info-panel">
            <div class="info-surface">
                <div id="info-header" class="info-header" title="Открыть / закрыть">
                    <div id="info-title" class="info-header-title">Информация</div>
                    <button id="toggle-info" class="toggle-btn" aria-label="toggle">
                        <i id="toggle-info-icon" class="fa-solid fa-arrow-left"></i>
                    </button>
                </div>

                <div id="person-info" class="info-content">Выберите человека</div>
            </div>
        </div>

    </div>

    <div id="admin-modal" class="admin-modal" aria-hidden="true">
        <div class="admin-dialog" role="dialog" aria-modal="true" aria-labelledby="admin-title">
            <h2 id="admin-title">Вход администратора</h2>
            <div id="admin-note" class="admin-note">Введите пароль администратора, чтобы открыть режим управления.</div>
            <form id="admin-login-form" class="admin-row">
                <label for="admin-email">Почта</label>
                <input id="admin-email" type="email" autocomplete="email" required />
                <label for="admin-password">Пароль</label>
                <input id="admin-password" type="password" autocomplete="current-password" required />
                <label id="admin-password-confirm-label" for="admin-password-confirm" style="display:none;">Повторите пароль</label>
                <input id="admin-password-confirm" type="password" autocomplete="new-password" style="display:none;" />
                <div class="admin-actions">
                    <button class="admin-btn" type="submit">Войти</button>
                    <button class="admin-btn secondary" type="button" id="admin-cancel">Отмена</button>
                </div>
            </form>
            <div id="admin-error" class="admin-error"></div>
        </div>
    </div>

    <script>
        /* ================= STATE ================= */
        let data = null;
        let rootId = null;
        let rawGedText = '';
        let isAdmin = false;
        let mediaMap = {};
        let infoMap = {};
        let supabaseClient = null;

        let currentId = null;
        let focusRawId = null;
        let focusResolvedId = null;

        let svg = null, g = null, zoom = null, layout = null;
        let w = 0, h = 0;

        let lastTransform = d3.zoomIdentity;
        let lastRenderedRoot = null;

        /* ================= CONFIG ================= */
        const CARD_W = 230;
        const CARD_H = 90;
        const COUPLE_GAP = 8;
        const COUPLE_TOTAL_H = CARD_H * 2 + COUPLE_GAP;

        const NODE_X = COUPLE_TOTAL_H + 14;
        const NODE_Y = 250;
        const SEP_SIBLINGS = 1.0;
        const SEP_OTHER = 1.12;

        const ANIM_MS = 900;

        const PAN_MS = 900;
        const PAN_EASE = d3.easeCubicInOut;

        const MARRIAGE_ICON = 'fa-heart';

        const DEFAULT_ADMIN_PASSWORD = 'poru4ik2087';

        const STORAGE_GED_KEY = 'serbell:ged';
        const STORAGE_ADMIN_KEY = 'serbell:admin';
        const STORAGE_UPDATED_KEY = 'serbell:ged:updatedAt';
        const STORAGE_MEDIA_KEY = 'serbell:media';
        const STORAGE_ADMIN_HASH_KEY = 'serbell:admin:hash';
        const STORAGE_ADMIN_EMAIL_KEY = 'serbell:admin:email';
        const STORAGE_SUPABASE_URL_KEY = 'serbell:supabase:url';
        const STORAGE_SUPABASE_ANON_KEY = 'serbell:supabase:anon';
        const STORAGE_SUPABASE_BUCKET_KEY = 'serbell:supabase:bucket';
        const STORAGE_INFO_KEY = 'serbell:info';

        /* ================= INIT ================= */
        isAdmin = localStorage.getItem(STORAGE_ADMIN_KEY) === '1';
        hydrateSupabaseConfig();
        supabaseClient = initSupabaseClient();
        mediaMap = loadMediaMap();
        infoMap = loadInfoMap();
        ensureDefaultAdminPassword();

        loadGedSource()
            .then(t => {
                applyGedText(t);
                initSvgOnce();
                render(true);
                setupUI();
                updateInfoUI();
                updateAdminUI();
                syncSheetMetricsLater();
                // стартуем на мобиле в collapsed
                if (isPortrait()) setSheetState('collapsed');
            })
            .catch(e => console.error('GED load error', e));

        function loadGedSource() {
            const cached = localStorage.getItem(STORAGE_GED_KEY);
            if (cached) return Promise.resolve(cached);
            return fetch('./3.ged').then(r => r.text());
        }

        function applyGedText(text, { persist = false } = {}) {
            rawGedText = text || '';
            data = parseGedcom(rawGedText);
            rootId = findRoot();
            currentId = null;
            focusRawId = null;
            focusResolvedId = null;
            cleanupMediaMap();
            cleanupInfoMap();
            if (persist) {
                localStorage.setItem(STORAGE_GED_KEY, rawGedText);
                localStorage.setItem(STORAGE_UPDATED_KEY, new Date().toISOString());
            }
        }

        function initSvgOnce() {
            const container = document.getElementById('tree');
            w = container.clientWidth;
            h = container.clientHeight;

            svg = d3.select('#tree').append('svg')
                .attr('width', w)
                .attr('height', h);

            g = svg.append('g');
            const defs = svg.append('defs');
            defs.append('clipPath')
                .attr('id', 'avatarClip')
                .append('circle')
                .attr('cx', 26)
                .attr('cy', 26)
                .attr('r', 26);

            zoom = d3.zoom()
                .scaleExtent([0.15, 3])
                .on('zoom', e => {
                    lastTransform = e.transform;
                    g.attr('transform', e.transform);
                });

            svg.call(zoom);
            svg.call(zoom.transform, lastTransform);

            layout = d3.tree()
                .nodeSize([NODE_X, NODE_Y])
                .separation((a, b) => a.parent === b.parent ? SEP_SIBLINGS : SEP_OTHER);
        }

        /* ================= GEDCOM ================= */
        function parseGedcom(t) {
            const people = {}, fams = {};
            let cur = null, evt = null;

            t.split(/\r?\n/).forEach(l => {
                const m = l.match(/^(\d+)\s+(@?[^ ]+@?)\s*(.*)$/);
                if (!m) return;

                const lvl = +m[1];
                const tag = m[2].replace(/@/g, '');
                const val = m[3];

                if (lvl === 0) {
                    evt = null;
                    if (val.includes('INDI')) {
                        cur = { t: 'P', id: tag };
                        people[tag] = { id: tag, name: '', sex: '', birth: '', death: '', FAMS: [], FAMC: [] };
                    } else if (val.includes('FAM')) {
                        cur = { t: 'F', id: tag };
                        fams[tag] = { id: tag, husb: null, wife: null, chil: [], marriage: '' };
                    } else cur = null;
                    return;
                }

                if (!cur) return;

                if (lvl === 1) {
                    evt = null;
                    if (tag === 'BIRT') evt = 'birth';
                    if (tag === 'DEAT') evt = 'death';
                    if (tag === 'MARR') evt = 'marriage';
                }

                if (cur.t === 'P') {
                    const p = people[cur.id];
                    if (tag === 'NAME') p.name = val.replace(/\//g, '').trim();
                    if (tag === 'SEX') p.sex = val;
                    if (tag === 'FAMS') p.FAMS.push(val.replace(/@/g, ''));
                    if (tag === 'FAMC') p.FAMC.push(val.replace(/@/g, ''));
                    if (lvl === 2 && evt && tag === 'DATE') p[evt] = val.trim();
                }

                if (cur.t === 'F') {
                    const f = fams[cur.id];
                    if (tag === 'HUSB') f.husb = val.replace(/@/g, '');
                    if (tag === 'WIFE') f.wife = val.replace(/@/g, '');
                    if (tag === 'CHIL') f.chil.push(val.replace(/@/g, ''));
                    if (lvl === 2 && evt && tag === 'DATE') f[evt] = val.trim();
                }
            });

            return { people, fams };
        }

        function findRoot() {
            const ids = Object.keys(data.people);
            return ids.find(id => !(data.people[id].FAMC || []).length) || ids[0];
        }

        /* ================= SUPABASE ================= */
        function getSupabaseConfig() {
            return {
                url: window.SUPABASE_URL || '',
                anonKey: window.SUPABASE_ANON_KEY || '',
                bucket: window.SUPABASE_BUCKET || 'person-media'
            };
        }

        function hydrateSupabaseConfig() {
            const storedUrl = localStorage.getItem(STORAGE_SUPABASE_URL_KEY) || '';
            const storedKey = localStorage.getItem(STORAGE_SUPABASE_ANON_KEY) || '';
            const storedBucket = localStorage.getItem(STORAGE_SUPABASE_BUCKET_KEY) || '';
            if (!window.SUPABASE_URL && storedUrl) window.SUPABASE_URL = storedUrl;
            if (!window.SUPABASE_ANON_KEY && storedKey) window.SUPABASE_ANON_KEY = storedKey;
            if (!window.SUPABASE_BUCKET && storedBucket) window.SUPABASE_BUCKET = storedBucket;
        }

        function persistSupabaseConfig({ url, anonKey, bucket }) {
            if (url) localStorage.setItem(STORAGE_SUPABASE_URL_KEY, url);
            if (anonKey) localStorage.setItem(STORAGE_SUPABASE_ANON_KEY, anonKey);
            if (bucket) localStorage.setItem(STORAGE_SUPABASE_BUCKET_KEY, bucket);
            window.SUPABASE_URL = url;
            window.SUPABASE_ANON_KEY = anonKey;
            window.SUPABASE_BUCKET = bucket;
        }

        function initSupabaseClient() {
            const { url, anonKey } = getSupabaseConfig();
            if (!url || !anonKey) return null;
            if (!window.supabase?.createClient) return null;
            return window.supabase.createClient(url, anonKey);
        }

        function ensureSupabaseClient() {
            if (supabaseClient) return supabaseClient;
            supabaseClient = initSupabaseClient();
            return supabaseClient;
        }

        /* ================= TREE BUILD ================= */
        function buildDisplayTree(personId, seen = new Set()) {
            if (!personId || seen.has(personId)) return null;
            seen.add(personId);

            const p = data.people[personId];
            if (!p) return null;

            const fams = (p.FAMS || []).map(fid => data.fams[fid]).filter(Boolean);

            const mainFam = fams.find(f => {
                const spouse = (f.husb === personId) ? f.wife : f.husb;
                return !!spouse || (f.chil && f.chil.length);
            });

            if (mainFam) {
                const spouseId = (mainFam.husb === personId) ? mainFam.wife : mainFam.husb;
                const node = {
                    type: 'couple',
                    primaryId: personId,
                    spouseId: spouseId || null,
                    marriage: mainFam.marriage || '',
                    children: []
                };

                (mainFam.chil || []).forEach(cid => {
                    const ch = buildDisplayTree(cid, new Set(seen));
                    if (ch) node.children.push(ch);
                });

                if (!node.children.length) delete node.children;
                return node;
            }

            return {
                type: 'person',
                id: personId,
                name: p.name || 'Без имени',
                sex: p.sex || '',
                b: p.birth || '',
                d: p.death || '',
            };
        }

        function dataPrimaryId(node) {
            if (!node) return null;
            if (node.type === 'couple') return node.primaryId;
            if (node.type === 'person') return node.id;
            return null;
        }

        function resolveFocusTarget(rootH, clickedId) {
            let found = null;
            rootH.each(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid === clickedId) found = pid;
            });
            if (found) return found;

            let couplePrimary = null;
            rootH.each(d => {
                if (d.data.type === 'couple' && d.data.spouseId === clickedId) {
                    couplePrimary = d.data.primaryId;
                }
            });
            return couplePrimary || clickedId;
        }

        /* ================= BRANCH + SIBLINGS ================= */
        function computeBranchIds(rootH, targetPersonId) {
            let targetNode = null;
            rootH.each(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid === targetPersonId) targetNode = d;
            });
            if (!targetNode) return new Set();

            const ids = new Set();
            targetNode.ancestors().forEach(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid) ids.add(pid);
            });
            targetNode.descendants().forEach(d => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                if (pid) ids.add(pid);
            });
            return ids;
        }

        function getSiblingIds(personId) {
            const p = data.people[personId];
            if (!p) return [];
            const famc = (p.FAMC || [])[0];
            if (!famc) return [];
            const fam = data.fams[famc];
            if (!fam) return [];
            const kids = fam.chil || [];
            return kids.filter(id => id && id !== personId);
        }

        function expandIdsWithSiblingsFlat(baseIds, targetPersonId) {
            const out = new Set(baseIds);
            const sibs = getSiblingIds(targetPersonId);
            for (const sid of sibs) out.add(sid);
            return out;
        }

        function pruneDataByIds(node, keepIds, siblingSet) {
            if (!node) return null;

            const selfId = dataPrimaryId(node);
            const isSibling = selfId && siblingSet && siblingSet.has(selfId);

            if (isSibling) {
                const p = data.people[selfId];
                return {
                    type: 'person',
                    id: selfId,
                    name: p?.name || 'Без имени',
                    sex: p?.sex || '',
                    b: p?.birth || '',
                    d: p?.death || ''
                };
            }

            const selfKept = selfId ? keepIds.has(selfId) : false;

            const kids = (node.children || [])
                .map(ch => pruneDataByIds(ch, keepIds, siblingSet))
                .filter(Boolean);

            if (selfKept || kids.length) {
                const copy = { ...node };
                if (kids.length) copy.children = kids;
                else delete copy.children;
                return copy;
            }
            return null;
        }

        /* ================= COLORS ================= */
        function setBranchColorFromId(personId) {
            const hue = hashHue(String(personId || 'x'));
            const css = `hsla(${hue}, 92%, 62%, .88)`;
            document.documentElement.style.setProperty('--branch-color', css);
        }
        function hashHue(s) {
            let h = 0;
            for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
            return h % 360;
        }

        /* ================= APP-LIKE CENTERING (PAN ONLY) ================= */
        function isPortrait() {
            return window.matchMedia('(max-aspect-ratio: 1/1)').matches;
        }

        function getAvailableViewportRect() {
            const panel = document.getElementById('info-panel');
            const state = panel?.dataset?.state || 'collapsed';
            const open = isPortrait() ? (state !== 'collapsed') : panel?.classList.contains('open');

            let left = 0, top = 0, right = w, bottom = h;

            if (!panel || !open) {
                return { left, top, right, bottom, cx: (left + right) / 2, cy: (top + bottom) / 2 };
            }

            const r = panel.getBoundingClientRect();

            if (isPortrait()) {
                bottom = Math.max(0, Math.min(h, r.top));
            } else {
                right = Math.max(0, Math.min(w, r.left));
            }

            if (right - left < 120 || bottom - top < 120) {
                left = 0; top = 0; right = w; bottom = h;
            }

            return { left, top, right, bottom, cx: (left + right) / 2, cy: (top + bottom) / 2 };
        }

        function computeTreeBounds(renderRoot) {
            const nodes = renderRoot.descendants();
            if (!nodes.length) return null;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

            for (const n of nodes) {
                const vHalf = (n.data.type === 'couple') ? (COUPLE_TOTAL_H / 2) : (CARD_H / 2);
                const hHalf = (CARD_W / 2);

                minX = Math.min(minX, n.x - vHalf);
                maxX = Math.max(maxX, n.x + vHalf);

                minY = Math.min(minY, n.y - hHalf);
                maxY = Math.max(maxY, n.y + hHalf);
            }

            return { minX, maxX, minY, maxY, cx: (minX + maxX) / 2, cy: (minY + maxY) / 2 };
        }

        function panTreeToAvailableCenter(renderRoot) {
            if (!renderRoot) return;
            const b = computeTreeBounds(renderRoot);
            if (!b) return;

            const k = lastTransform.k || 1;
            const avail = getAvailableViewportRect();

            const tx = avail.cx - (b.cy * k);
            const ty = avail.cy - (b.cx * k);

            const next = d3.zoomIdentity.translate(tx, ty).scale(k);

            svg.interrupt();
            svg.transition()
                .duration(PAN_MS)
                .ease(PAN_EASE)
                .call(zoom.transform, next);
        }

        /* ================= LINK ANCHORS ================= */
        function getLinkSourceAnchor(node) {
            if (!node) return { x: 0, y: 0 };
            const y = node.y + (CARD_W / 2);
            return { x: node.x, y };
        }

        function getLinkTargetAnchor(node) {
            if (!node) return { x: 0, y: 0 };
            const d = node.data;
            const y = node.y - (CARD_W / 2);

            if (d.type === 'couple') {
                const half = (CARD_H + COUPLE_GAP) / 2;
                const topCardCenterX = node.x - half;
                return { x: topCardCenterX, y };
            }
            return { x: node.x, y };
        }

        /* ================= NODE DRAW ================= */
        function drawNode(gNode, n, fullRoot) {
            if (n.type === 'person') {
                const p = data.people[n.id] || { name: n.name, sex: n.sex, birth: n.b, death: n.d };
                drawPersonCard(gNode, {
                    id: n.id,
                    name: p.name || n.name,
                    sex: p.sex || n.sex,
                    b: p.birth || n.b,
                    d: p.death || n.d
                }, 0, fullRoot);
                return;
            }

            if (n.type === 'couple') {
                const primary = data.people[n.primaryId];
                const spouse = n.spouseId ? data.people[n.spouseId] : null;
                const half = (CARD_H + COUPLE_GAP) / 2;

                drawPersonCard(gNode, {
                    id: n.primaryId,
                    name: primary?.name || 'Без имени',
                    sex: primary?.sex || '',
                    b: primary?.birth || '',
                    d: primary?.death || ''
                }, -half, fullRoot);

                if (spouse) {
                    drawPersonCard(gNode, {
                        id: n.spouseId,
                        name: spouse?.name || 'Без имени',
                        sex: spouse?.sex || '',
                        b: spouse?.birth || '',
                        d: spouse?.death || ''
                    }, +half, fullRoot);
                }

                gNode.append('path')
                    .attr('d', `M 0 ${-half + CARD_H / 2} L 0 ${+half - CARD_H / 2}`)
                    .attr('fill', 'none')
                    .attr('stroke', getCssVar('--link-strong'))
                    .attr('stroke-width', 1.4);

                const marriage = formatGedcomDate(n.marriage);
                const W = marriage ? 200 : 56;
                const H = 32;

                gNode.append('foreignObject')
                    .attr('x', -W / 2).attr('y', -H / 2)
                    .attr('width', W).attr('height', H)
                    .style('pointer-events', 'none')
                    .append('xhtml:div')
                    .style('width', '100%')
                    .style('height', '100%')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('justify-content', 'center')
                    .html(`
            <div style="
              display:inline-flex;align-items:center;gap:${marriage ? 8 : 0}px;
              padding:5px 12px;border-radius:999px;
              background:rgba(255,255,255,.92);
              border:1px solid rgba(15,23,42,.08);
              box-shadow: 0 10px 22px rgba(0,0,0,.12);
              font-size:11px;color:rgba(15,23,42,.82);
              font-weight:700;
            ">
              <i class="fa-solid ${escapeHtml(MARRIAGE_ICON)}" style="font-size:16px;color:${escapeHtml(getCssVar('--ring'))}"></i>
              ${marriage ? `<span>${escapeHtml(marriage)}</span>` : ``}
            </div>
          `);

                const kidsCount = (n.children && n.children.length) ? n.children.length : 0;
                if (kidsCount > 0) {
                    const chipW = 70, chipH = 26;
                    const chipX = (-CARD_W / 2) + 10;
                    const chipY = (-half - CARD_H / 2) + 10;

                    gNode.append('foreignObject')
                        .attr('x', chipX)
                        .attr('y', chipY)
                        .attr('width', chipW)
                        .attr('height', chipH)
                        .style('pointer-events', 'none')
                        .append('xhtml:div')
                        .style('width', '100%')
                        .style('height', '100%')
                        .style('display', 'flex')
                        .style('align-items', 'center')
                        .style('justify-content', 'center')
                        .html(`
              <div style="
                width:100%;height:100%;
                display:flex;align-items:center;justify-content:center;gap:7px;
                border-radius:999px;
                background:rgba(15,23,42,.06);
                border:1px solid rgba(15,23,42,.10);
                color:rgba(15,23,42,.78);
                font-size:11px;font-weight:700;
              ">
                <i class="fa-solid fa-children" style="font-size:12px;"></i>
                <span>${kidsCount}</span>
              </div>
            `);
                }
            }
        }

        function drawPersonCard(gNode, p, yOffset, fullRoot) {
            const cls = p.sex === 'M' ? 'm' : p.sex === 'F' ? 'f' : 'u';

            const group = gNode.append('g')
                .attr('transform', `translate(0,${yOffset})`)
                .style('cursor', 'pointer')
                .on('click', (ev) => { ev.stopPropagation(); onPersonClick(p.id, fullRoot); });

            group.append('rect')
                .attr('class', 'person-outer card-shadow ' + cls)
                .attr('x', -CARD_W / 2).attr('y', -CARD_H / 2)
                .attr('width', CARD_W).attr('height', CARD_H)
                .attr('rx', 18);

            const photo = getPrimaryImage(p.id);
            if (photo) {
                const size = 52;
                group.append('image')
                    .attr('href', photo)
                    .attr('x', -CARD_W / 2 + 12)
                    .attr('y', -size / 2)
                    .attr('width', size)
                    .attr('height', size)
                    .attr('clip-path', 'url(#avatarClip)');
            }

            const lines = splitName3(p.name);
            const text = group.append('text')
                .attr('text-anchor', 'middle')
                .attr('y', -20)
                .style('font-weight', '700')
                .style('font-size', '12.5px')
                .style('fill', getCssVar('--card-text'));

            lines.forEach((ln, idx) => {
                text.append('tspan')
                    .attr('x', 0)
                    .attr('dy', idx === 0 ? 0 : 14)
                    .text(shorten(ln, 30));
            });

            const life = formatLifeLine(p);
            if (life) {
                group.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('y', 34)
                    .style('font-size', '11px')
                    .style('font-weight', '600')
                    .style('fill', getCssVar('--card-muted'))
                    .text(life);
            }

            if (p.id === currentId) gNode.classed('selected', true);
            else gNode.classed('selected', false);
        }

        /* ================= INFO PANEL ================= */
        function selectPerson(id, doRerender = true) {
            currentId = id;
            updateInfoUI();
            void refreshPersonMedia(id);
            void refreshPersonInfo(id);

            // Mobile: при выборе человека держим карточку в свернутом состоянии (peek)
            if (isPortrait()) {
                syncSheetMetricsLater();
                setSheetState('collapsed', { keepTitle: true });
            }

            if (doRerender) render(false);
        }

        function renderMiniPerson(p) {
            const name = escapeHtml(p?.name || 'Без имени');
            const b = formatGedcomDate(p?.birth || '');
            const d = formatGedcomDate(p?.death || '');
            const life = (b && d) ? `${b} — ${d}` : (b || d || '');
            return `
        <div class="list-item" data-person-id="${escapeHtml(p.id)}">
          <div class="li-name">${name}</div>
          ${life ? `<div class="li-meta">${escapeHtml(life)}</div>` : ``}
        </div>
      `;
        }

        function getChildrenIds(personId) {
            const p = data.people[personId];
            if (!p) return [];
            const out = new Set();
            (p.FAMS || []).forEach(fid => {
                const fam = data.fams[fid];
                if (!fam) return;
                (fam.chil || []).forEach(cid => { if (cid) out.add(cid); });
            });
            return Array.from(out);
        }

        // ✅ Таб: Фамилия вертикально + инициалы
        function renderVerticalNameToTab() {
            const el = document.getElementById('info-tab-label');
            if (!el) return;

            el.innerHTML = '';
            if (!currentId) return;

            const full = String(data.people[currentId]?.name || '').trim().replace(/\s+/g, ' ');
            if (!full) return;

            const parts = full.split(' ').filter(Boolean);
            const first = parts[0] || '';
            const patronymic = parts.length >= 3 ? parts[1] : '';
            const last = parts.length >= 2 ? parts[parts.length - 1] : '';

            const initials = [
                first ? (first[0].toUpperCase() + '.') : '',
                patronymic ? (patronymic[0].toUpperCase() + '.') : ''
            ].filter(Boolean).join('');

            // Сначала фамилия (главное), ниже инициалы
            const words = [];
            if (last) words.push({ text: last, muted: false });
            if (initials) words.push({ text: initials, muted: true });

            for (const w of words) {
                const ww = document.createElement('div');
                ww.className = 'vword';
                for (const ch of String(w.text)) {
                    const c = document.createElement('div');
                    c.className = 'vchar' + (w.muted ? ' muted' : '');
                    c.textContent = ch;
                    ww.appendChild(c);
                }
                el.appendChild(ww);
            }
        }

        function renderMediaSection(personId) {
            const media = getPersonMedia(personId);
            if (!media.length) {
                return `
            <div class="media-empty">Нет медиа</div>`;
            }
            return `
            <div class="media-grid">
                ${media.map(item => renderMediaCard(item, { removable: false })).join('')}
            </div>`;
        }

        function renderMediaCard(item, { removable }) {
            const url = getMediaUrl(item);
            const safeUrl = escapeHtml(url);
            const isVideo = item?.media_type === 'video';
            const removeButton = removable
                ? `<button class="media-remove" type="button" data-media-id="${escapeHtml(item.id)}" aria-label="Удалить медиа">
                        <i class="fa-solid fa-xmark"></i>
                   </button>`
                : '';
            return `
                <div class="media-card">
                    ${isVideo
                    ? `<video src="${safeUrl}" controls preload="metadata"></video>`
                    : `<img src="${safeUrl}" alt="Медиа" loading="lazy" />`}
                    ${removeButton}
                </div>`;
        }

        function renderPersonInfoSection(personId) {
            const html = getPersonInfo(personId);
            if (!html) return '';
            return `
            <div class="section">
                <div class="section-title">Информация о человеке</div>
                <div>${html}</div>
            </div>`;
        }

        function renderAdminSection(person) {
            if (!isAdmin) return '';
            const updatedAt = localStorage.getItem(STORAGE_UPDATED_KEY);
            const updatedLabel = updatedAt ? new Date(updatedAt).toLocaleString('ru-RU') : '—';
            const fileInfo = rawGedText ? `${rawGedText.split(/\r?\n/).length} строк` : 'нет данных';
            const sexValue = person?.sex || '';
            const mediaItems = getPersonMedia(person?.id);
            const { url: supaUrl, anonKey: supaKey, bucket: supaBucket } = getSupabaseConfig();
            const disabled = person ? '' : 'disabled';
            const addNote = person ? '' : '<div class="admin-note">Сначала выберите человека.</div>';
            const infoHtml = getPersonInfo(person?.id) || '';
            const birthInput = toInputDate(person?.birth || '');
            const deathInput = toInputDate(person?.death || '');

            const editForm = person ? `
            <form id="admin-edit-form" class="admin-card">
                <div class="section-title">Редактирование человека</div>
                <div class="admin-row">
                    <label for="admin-name">ФИО</label>
                    <input id="admin-name" type="text" value="${escapeHtml(person?.name || '')}" />
                </div>
                <div class="admin-row">
                    <label for="admin-sex">Пол</label>
                    <select id="admin-sex">
                        <option value="" ${sexValue === '' ? 'selected' : ''}>—</option>
                        <option value="M" ${sexValue === 'M' ? 'selected' : ''}>Мужской</option>
                        <option value="F" ${sexValue === 'F' ? 'selected' : ''}>Женский</option>
                    </select>
                </div>
                <div class="admin-row">
                    <label for="admin-birth">Дата рождения</label>
                    <input id="admin-birth" type="date" value="${escapeHtml(birthInput)}" />
                </div>
                <div class="admin-row">
                    <label for="admin-death">Дата смерти</label>
                    <input id="admin-death" type="date" value="${escapeHtml(deathInput)}" />
                </div>
                <div class="admin-row">
                    <label for="admin-media">Медиа</label>
                    ${mediaItems.length ? `
                        <div class="media-grid">
                            ${mediaItems.map(item => renderMediaCard(item, { removable: true })).join('')}
                        </div>
                    ` : `<div class="media-empty">Медиа не загружено</div>`}
                    <input id="admin-media" type="file" accept="image/*,video/*" multiple />
                    <div id="admin-media-status" class="admin-note"></div>
                    <div class="admin-note">Поддерживаются изображения и видео. Можно выбирать несколько файлов.</div>
                </div>
                <div class="admin-row">
                    <label>Информация о человеке</label>
                    <div class="rich-toolbar">
                        <button type="button" data-command="bold"><i class="fa-solid fa-bold"></i></button>
                        <button type="button" data-command="italic"><i class="fa-solid fa-italic"></i></button>
                        <button type="button" data-command="underline"><i class="fa-solid fa-underline"></i></button>
                        <button type="button" data-command="insertUnorderedList"><i class="fa-solid fa-list-ul"></i></button>
                    </div>
                    <div id="admin-info-editor" class="rich-editor" contenteditable="true">${infoHtml}</div>
                </div>
                <div class="admin-actions">
                    <button class="admin-btn" type="submit">Сохранить</button>
                    <button class="admin-btn secondary" type="button" id="admin-reset-fields">Сбросить</button>
                </div>
            </form>
            ` : `
            <div class="admin-card">
                <div class="section-title">Редактирование человека</div>
                <div class="admin-note">Выберите человека на дереве, чтобы открыть редактирование.</div>
            </div>`;

            return `
            <div class="admin-section">
                <div class="section-title">Администрирование</div>
                <div class="admin-card">
                    <div class="section-title">Админ-сессия</div>
                    <div class="admin-actions">
                        <button class="admin-btn secondary" type="button" id="admin-logout">Выйти</button>
                    </div>
                    <div class="admin-note">GEDCOM: ${fileInfo}. Последнее обновление: ${updatedLabel}</div>
                </div>
                <form id="admin-add-relative" class="admin-card">
                    <div class="section-title">Добавить родственника</div>
                    <div class="admin-row">
                        <label for="admin-relation">Кем приходится</label>
                        <select id="admin-relation" ${disabled}>
                            <option value="child">Ребёнок</option>
                            <option value="spouse">Супруг/супруга</option>
                            <option value="parent">Родитель</option>
                            <option value="sibling">Брат/сестра</option>
                        </select>
                    </div>
                    <div class="admin-row">
                        <label for="admin-new-name">ФИО</label>
                        <input id="admin-new-name" type="text" placeholder="ФИО нового человека" ${disabled} />
                    </div>
                    <div class="admin-row">
                        <label for="admin-new-sex">Пол</label>
                        <select id="admin-new-sex" ${disabled}>
                            <option value="">—</option>
                            <option value="M">Мужской</option>
                            <option value="F">Женский</option>
                        </select>
                    </div>
                    <div class="admin-row">
                        <label for="admin-new-birth">Дата рождения</label>
                        <input id="admin-new-birth" type="date" ${disabled} />
                    </div>
                    <div class="admin-row">
                        <label for="admin-new-death">Дата смерти</label>
                        <input id="admin-new-death" type="date" ${disabled} />
                    </div>
                    <div class="admin-actions">
                        <button class="admin-btn" type="submit" ${disabled}>Добавить</button>
                    </div>
                    ${addNote}
                </form>
                <div class="admin-card">
                    <div class="section-title">Удаление</div>
                    <div class="admin-note">Удаление человека удалит его из всех семейных связей.</div>
                    <div class="admin-actions">
                        <button class="admin-btn secondary" type="button" id="admin-delete-person" ${disabled}>Удалить выбранного</button>
                    </div>
                </div>
                <form id="admin-supabase" class="admin-card">
                    <div class="section-title">Supabase синхронизация</div>
                    <div class="admin-row">
                        <label for="admin-supabase-url">SUPABASE_URL</label>
                        <input id="admin-supabase-url" type="text" value="${escapeHtml(supaUrl)}" placeholder="https://project.supabase.co" />
                    </div>
                    <div class="admin-row">
                        <label for="admin-supabase-key">SUPABASE_ANON_KEY</label>
                        <input id="admin-supabase-key" type="text" value="${escapeHtml(supaKey)}" placeholder="anon key" />
                    </div>
                    <div class="admin-row">
                        <label for="admin-supabase-bucket">SUPABASE_BUCKET</label>
                        <input id="admin-supabase-bucket" type="text" value="${escapeHtml(supaBucket)}" placeholder="person-media" />
                    </div>
                    <div class="admin-actions">
                        <button class="admin-btn" type="submit">Сохранить Supabase</button>
                        <button class="admin-btn secondary" type="button" id="admin-supabase-login">Войти через Google</button>
                    </div>
                    <div id="admin-supabase-status" class="admin-note"></div>
                </form>
                ${editForm}
            </div>`;
        }

        function updatePanelArrows() {
            const panel = document.getElementById('info-panel');
            const tab = document.getElementById('info-tab');

            const state = panel?.dataset?.state || 'collapsed';
            const desktopOpen = panel?.classList.contains('open');

            // Desktop tab follows desktop open state
            if (tab) tab.classList.toggle('open', desktopOpen);

            const tabArrow = document.getElementById('info-tab-arrow');
            if (tabArrow) {
                tabArrow.innerHTML = desktopOpen
                    ? `<i class="fa-solid fa-arrow-right"></i>`
                    : `<i class="fa-solid fa-arrow-left"></i>`;
            }

            // Toggle icon adapts for mobile states
            const icon = document.getElementById('toggle-info-icon');
            if (!icon) return;

            if (isPortrait()) {
                // collapsed -> up (expand), half/full -> down (collapse)
                icon.className = (state === 'collapsed') ? 'fa-solid fa-arrow-up' : 'fa-solid fa-arrow-down';
            } else {
                icon.className = desktopOpen ? 'fa-solid fa-arrow-right' : 'fa-solid fa-arrow-left';
            }
        }

        function getSheetState() {
            const panel = document.getElementById('info-panel');
            return panel?.dataset?.state || 'collapsed';
        }

        function setSheetState(state, opts = {}) {
            const panel = document.getElementById('info-panel');
            const scrim = document.getElementById('sheet-scrim');
            if (!panel) return;

            panel.dataset.state = state;

            // Keep legacy 'open' class for calculations (occupied viewport)
            if (isPortrait()) {
                panel.classList.toggle('open', state !== 'collapsed');
                if (scrim) scrim.classList.toggle('show', state === 'half');
            }

            updatePanelArrows();
            // Не панорамируем дерево автоматически при смене состояния панели
        }

        function syncSheetMetricsLater() {
            if (!isPortrait()) return;
            // два rAF чтобы дождаться раскладки/шрифтов
            requestAnimationFrame(() => requestAnimationFrame(() => syncSheetMetrics()));
        }

        function syncSheetMetrics() {
            if (!isPortrait()) return;
            const panel = document.getElementById('info-panel');
            const header = document.getElementById('info-header');
            if (!panel || !header) return;

            const headerH = Math.ceil(header.getBoundingClientRect().height) + 2;
            document.documentElement.style.setProperty('--sheet-peek', `${headerH}px`);

            // half height: 55% of viewport but not bigger than panel height
            const panelH = Math.min(window.innerHeight * 0.78, 620);
            const half = Math.min(panelH, Math.max(headerH + 140, Math.round(window.innerHeight * 0.55)));
            document.documentElement.style.setProperty('--sheet-half', `${half}px`);
        }

        function togglePanel(force) {
            const panel = document.getElementById('info-panel');

            if (!isPortrait()) {
                // Desktop: классический open/close
                if (typeof force === 'boolean') panel.classList.toggle('open', force);
                else panel.classList.toggle('open');
                updatePanelArrows();
                // Не панорамируем дерево автоматически при смене состояния панели
                return;
            }

            // Mobile: state machine (collapsed <-> half)
            syncSheetMetricsLater();

            let next;
            if (typeof force === 'boolean') {
                next = force ? 'half' : 'collapsed';
            } else {
                const cur = getSheetState();
                next = (cur === 'collapsed') ? 'half' : 'collapsed';
            }
            setSheetState(next);
        }

        function updateInfoUI() {
            const title = document.getElementById('info-title');
            const p = currentId ? data.people[currentId] : null;

            title.textContent = p?.name ? p.name : 'Информация';
            renderVerticalNameToTab();

            const info = document.getElementById('person-info');
            const adminMarkup = renderAdminSection(p);
            if (!p) {
                info.innerHTML = `Выберите человека${adminMarkup}`;
            } else {
                const b = formatGedcomDate(p?.birth || '');
                const d = formatGedcomDate(p?.death || '');
                const sex = (p?.sex === 'M') ? 'Мужчина' : (p?.sex === 'F') ? 'Женщина' : '—';
                const mediaMarkup = renderMediaSection(p?.id);
                const infoMarkup = renderPersonInfoSection(p?.id);

                const siblings = getSiblingIds(currentId).map(id => data.people[id]).filter(Boolean);
                const children = getChildrenIds(currentId).map(id => data.people[id]).filter(Boolean);

                info.innerHTML = `
          <div style="font-weight:900;font-size:16px;color:#0f172a">${escapeHtml(p?.name || '')}</div>
          ${mediaMarkup}

          <div class="pill"><i class="fa-solid fa-user"></i> <span>${escapeHtml(sex)}</span></div>
          <div class="pill"><i class="fa-solid fa-cake-candles"></i> <span>${escapeHtml(b || '—')}</span></div>
          <div class="pill"><i class="fa-solid fa-skull"></i> <span>${escapeHtml(d || '—')}</span></div>

          <div class="section">
            <div class="section-title">Братья и сёстры (${siblings.length})</div>
            ${siblings.length ? `
              <div class="list">${siblings.map(sp => renderMiniPerson(sp)).join('')}</div>
            ` : `<div style="color:rgba(15,23,42,.55);font-size:12px;">Нет данных</div>`}
          </div>

          <div class="section">
            <div class="section-title">Дети (${children.length})</div>
            ${children.length ? `
              <div class="list">${children.map(ch => renderMiniPerson(ch)).join('')}</div>
            ` : `<div style="color:rgba(15,23,42,.55);font-size:12px;">Нет данных</div>`}
          </div>
          ${infoMarkup}
          ${adminMarkup}
        `;

                document.querySelectorAll('[data-person-id]').forEach(el => {
                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const id = el.getAttribute('data-person-id');
                        if (!id) return;
                        selectPerson(id, true);
                    });
                });
            }

            updatePanelArrows();
            syncSheetMetricsLater();
            if (isPortrait()) setSheetState('collapsed');
            bindAdminHandlers(p);
        }

        /* ================= FORMAT ================= */
        function splitName3(full) {
            const s = String(full || '').trim().replace(/\s+/g, ' ');
            if (!s) return ['Без имени'];
            const t = s.split(' ');
            if (t.length >= 3) {
                const first = t[0];
                const patronymic = t[1];
                const last = t.slice(2).join(' ');
                return [first, patronymic, last];
            }
            if (t.length === 2) return [t[0], t[1]];
            return [t[0]];
        }

        function formatGedcomDate(raw) {
            const s = String(raw || '').trim().toUpperCase();
            if (!s) return '';

            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
                const [yy, mm, dd] = s.split('-');
                return `${dd}.${mm}.${yy}`;
            }

            const approx = s.startsWith('ABT ') || s.startsWith('EST ') || s.startsWith('CAL ');
            const before = s.startsWith('BEF ');
            const after = s.startsWith('AFT ');

            let x = s.replace(/^ABT\s+/, '')
                .replace(/^EST\s+/, '')
                .replace(/^CAL\s+/, '')
                .replace(/^BEF\s+/, '')
                .replace(/^AFT\s+/, '')
                .trim();

            if (/^\d{4}$/.test(x)) {
                if (approx) return `≈${x}`;
                if (before) return `<${x}`;
                if (after) return `>${x}`;
                return x;
            }

            const months = {
                JAN: '01', FEB: '02', MAR: '03', APR: '04', MAY: '05', JUN: '06',
                JUL: '07', AUG: '08', SEP: '09', OCT: '10', NOV: '11', DEC: '12'
            };

            const parts = x.split(/\s+/);
            if (parts.length === 3) {
                const dd = pad2(parts[0]);
                const mm = months[parts[1]] || '';
                const yyyy = parts[2];
                if (mm && /^\d{4}$/.test(yyyy)) {
                    const out = `${dd}.${mm}.${yyyy}`;
                    if (approx) return `≈${out}`;
                    if (before) return `<${out}`;
                    if (after) return `>${out}`;
                    return out;
                }
            }
            if (parts.length === 2) {
                const mm = months[parts[0]] || '';
                const yyyy = parts[1];
                if (mm && /^\d{4}$/.test(yyyy)) {
                    const out = `${mm}.${yyyy}`;
                    if (approx) return `≈${out}`;
                    if (before) return `<${out}`;
                    if (after) return `>${out}`;
                    return out;
                }
            }
            return raw.trim();
        }

        function toInputDate(raw) {
            const s = String(raw || '').trim();
            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
            const upper = s.toUpperCase();
            const parts = upper.split(' ').filter(Boolean);
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const mon = parts[1];
                const year = parts[2];
                const months = {
                    JAN: '01', FEB: '02', MAR: '03', APR: '04', MAY: '05', JUN: '06',
                    JUL: '07', AUG: '08', SEP: '09', OCT: '10', NOV: '11', DEC: '12'
                };
                if (months[mon] && /^\d{4}$/.test(year)) {
                    return `${year}-${months[mon]}-${day}`;
                }
            }
            return '';
        }

        function normalizeDateInput(value) {
            return String(value || '').trim();
        }

        function pad2(v) {
            const n = String(v || '').replace(/\D/g, '');
            if (!n) return '00';
            return n.length === 1 ? `0${n}` : n.slice(0, 2);
        }

        function formatLifeLine(p) {
            const b = formatGedcomDate(p?.b || '');
            const d = formatGedcomDate(p?.d || '');
            if (b && d) return `${b} — ${d}`;
            if (b) return b;
            if (d) return d;
            return '';
        }

        function escapeHtml(s) {
            return String(s || '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", "&#039;");
        }

        function shorten(s, n) {
            s = String(s || '');
            return s.length > n ? s.slice(0, n - 1) + '…' : s;
        }

        function getCssVar(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        function setAdminState(next) {
            isAdmin = next;
            localStorage.setItem(STORAGE_ADMIN_KEY, next ? '1' : '0');
            updateAdminUI();
            updateInfoUI();
        }

        function loadMediaMap() {
            try {
                const raw = localStorage.getItem(STORAGE_MEDIA_KEY);
                if (!raw) return {};
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch {
                return {};
            }
        }

        function loadInfoMap() {
            try {
                const raw = localStorage.getItem(STORAGE_INFO_KEY);
                if (!raw) return {};
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch {
                return {};
            }
        }

        function persistMediaMap() {
            localStorage.setItem(STORAGE_MEDIA_KEY, JSON.stringify(mediaMap));
        }

        function persistInfoMap() {
            localStorage.setItem(STORAGE_INFO_KEY, JSON.stringify(infoMap));
        }

        async function ensureDefaultAdminPassword() {
            if (hasAdminPassword()) return;
            const hash = await hashPassword(DEFAULT_ADMIN_PASSWORD);
            localStorage.setItem(STORAGE_ADMIN_HASH_KEY, hash);
        }

        function loadAdminEmail() {
            return localStorage.getItem(STORAGE_ADMIN_EMAIL_KEY) || '';
        }

        function persistAdminEmail(value) {
            if (value) localStorage.setItem(STORAGE_ADMIN_EMAIL_KEY, value);
        }

        function getPersonMedia(personId) {
            return personId && mediaMap[personId] ? [...mediaMap[personId]] : [];
        }

        function setPersonMedia(personId, items) {
            if (!personId) return;
            if (items && items.length) mediaMap[personId] = items;
            else delete mediaMap[personId];
            persistMediaMap();
        }

        function addMediaItem(personId, item) {
            if (!personId || !item) return;
            const next = getPersonMedia(personId);
            next.unshift(item);
            setPersonMedia(personId, next);
        }

        function removeMediaItem(personId, mediaId) {
            if (!personId || !mediaId) return;
            const next = getPersonMedia(personId).filter(item => item.id !== mediaId);
            setPersonMedia(personId, next);
        }

        function getMediaUrl(item) {
            if (!item?.media_path) return '';
            const path = String(item.media_path);
            if (path.startsWith('http') || path.startsWith('data:') || path.startsWith('blob:') || path.startsWith('./') || path.startsWith('/')) {
                return path;
            }
            const client = ensureSupabaseClient();
            if (!client) return path;
            const { bucket } = getSupabaseConfig();
            const { data } = client.storage.from(bucket).getPublicUrl(path);
            return data?.publicUrl || path;
        }

        function getPrimaryImage(personId) {
            const media = getPersonMedia(personId);
            const image = media.find(item => item.media_type === 'image');
            if (!image) return '';
            return getMediaUrl(image);
        }

        function getPersonInfo(personId) {
            return personId ? infoMap[personId] || '' : '';
        }

        function setPersonInfo(personId, html) {
            if (!personId) return;
            if (html) infoMap[personId] = html;
            else delete infoMap[personId];
            persistInfoMap();
        }

        function cleanupMediaMap() {
            if (!data?.people) return;
            Object.keys(mediaMap).forEach(id => {
                if (!data.people[id]) delete mediaMap[id];
            });
            persistMediaMap();
        }

        function cleanupInfoMap() {
            if (!data?.people) return;
            Object.keys(infoMap).forEach(id => {
                if (!data.people[id]) delete infoMap[id];
            });
            persistInfoMap();
        }

        async function refreshPersonMedia(personId) {
            const client = ensureSupabaseClient();
            if (!personId || !client) return;
            const { data: rows, error } = await client
                .from('person_media')
                .select('id, person_id, media_path, media_type, created_at')
                .eq('person_id', personId)
                .order('created_at', { ascending: false });
            if (error) {
                console.warn('media fetch error', error);
                return;
            }
            setPersonMedia(personId, rows || []);
            if (currentId === personId) updateInfoUI();
        }

        async function refreshPersonInfo(personId) {
            const client = ensureSupabaseClient();
            if (!personId || !client) return;
            const { data: rows, error } = await client
                .from('person_info')
                .select('person_id, info_html')
                .eq('person_id', personId)
                .limit(1);
            if (error) {
                console.warn('info fetch error', error);
                return;
            }
            const info = rows?.[0]?.info_html || '';
            if (info) infoMap[personId] = info;
            else delete infoMap[personId];
            persistInfoMap();
            if (currentId === personId) updateInfoUI();
        }

        function getMediaType(file) {
            if (file?.type?.startsWith('video/')) return 'video';
            return 'image';
        }

        function buildUniqueMediaPath(personId, file) {
            const rawExt = String(file?.name || '').split('.').pop();
            const ext = rawExt && rawExt !== file?.name ? `.${rawExt.toLowerCase()}` : '';
            return `${personId}/${crypto.randomUUID()}${ext}`;
        }

        async function uploadSingleMedia(personId, file) {
            const client = ensureSupabaseClient();
            if (!client) throw new Error('Supabase не настроен.');
            const mediaType = getMediaType(file);
            const path = buildUniqueMediaPath(personId, file);
            const { bucket } = getSupabaseConfig();
            const { error: uploadError } = await client.storage
                .from(bucket)
                .upload(path, file, { upsert: false });
            if (uploadError) throw uploadError;
            const { data: inserted, error: insertError } = await client
                .from('person_media')
                .insert({
                    person_id: personId,
                    media_path: path,
                    media_type: mediaType
                })
                .select('id, person_id, media_path, media_type, created_at')
                .single();
            if (insertError) throw insertError;
            return inserted;
        }

        async function uploadMediaFiles(personId, files) {
            const list = Array.from(files || []);
            if (!personId || !list.length) return;
            const status = document.getElementById('admin-media-status');
            const client = ensureSupabaseClient();
            if (!client) {
                if (status) status.textContent = 'Подключите Supabase, чтобы загрузить медиа.';
                return;
            }
            const { data: sessionData } = await client.auth.getSession();
            if (!sessionData?.session) {
                if (status) status.textContent = 'Войдите через Google, чтобы загрузить медиа.';
                return;
            }
            if (status) status.textContent = 'Загрузка...';

            const results = await Promise.allSettled(list.map(file => uploadSingleMedia(personId, file)));
            const successes = results.filter(r => r.status === 'fulfilled').map(r => r.value);
            if (successes.length) {
                const next = [...successes, ...getPersonMedia(personId)];
                setPersonMedia(personId, next);
                render(false);
                updateInfoUI();
            }

            const failed = results.filter(r => r.status === 'rejected');
            if (status) {
                if (failed.length) {
                    const message = failed[0]?.reason?.message || failed[0]?.reason?.toString() || 'ошибка загрузки';
                    status.textContent = `Загружено: ${successes.length}, ошибка: ${failed.length}. ${message}`;
                } else {
                    status.textContent = `Загружено: ${successes.length}`;
                }
            }
        }

        async function deleteMediaEntry(personId, mediaId) {
            if (!personId || !mediaId) return;
            const items = getPersonMedia(personId);
            const target = items.find(item => item.id === mediaId);
            if (!target) return;
            const client = ensureSupabaseClient();
            if (client) {
                const { error: deleteError } = await client
                    .from('person_media')
                    .delete()
                    .eq('id', mediaId);
                if (deleteError) {
                    console.warn('media delete error', deleteError);
                    return;
                }
                const path = target.media_path || '';
                if (path && !path.startsWith('http') && !path.startsWith('data:')) {
                    const { bucket } = getSupabaseConfig();
                    await client.storage.from(bucket).remove([path]);
                }
            }
            removeMediaItem(personId, mediaId);
            render(false);
            updateInfoUI();
        }

        async function deleteAllMediaForPerson(personId) {
            if (!personId) return;
            const client = ensureSupabaseClient();
            if (!client) return;
            const { data: rows, error } = await client
                .from('person_media')
                .select('id, media_path')
                .eq('person_id', personId);
            if (error) {
                console.warn('media bulk fetch error', error);
                return;
            }
            const paths = (rows || [])
                .map(row => row.media_path)
                .filter(path => path && !path.startsWith('http') && !path.startsWith('data:'));
            if (paths.length) {
                const { bucket } = getSupabaseConfig();
                await client.storage.from(bucket).remove(paths);
            }
            await client.from('person_media').delete().eq('person_id', personId);
            setPersonMedia(personId, []);
        }

        async function deletePersonInfo(personId) {
            if (!personId) return;
            const client = ensureSupabaseClient();
            if (!client) return;
            await client.from('person_info').delete().eq('person_id', personId);
            delete infoMap[personId];
            persistInfoMap();
        }

        async function upsertPersonInfo(personId, html) {
            if (!personId) return;
            const client = ensureSupabaseClient();
            if (!client) return;
            const { error } = await client
                .from('person_info')
                .upsert({ person_id: personId, info_html: html || '', updated_at: new Date().toISOString() })
                .select('person_id')
                .single();
            if (error) {
                console.warn('info save error', error);
            }
        }


        function updateAdminUI() {
            const btn = document.getElementById('admin-toggle');
            if (!btn) return;
            btn.classList.toggle('admin-active', isAdmin);
            btn.title = isAdmin ? 'Выйти из админки' : 'Войти как администратор';
            const icon = btn.querySelector('i');
            if (icon) icon.className = isAdmin ? 'fa-solid fa-right-from-bracket' : 'fa-solid fa-user-shield';

            const bar = document.getElementById('admin-bar');
            if (bar) bar.classList.toggle('active', isAdmin);
        }

        async function updateSupabaseStatus() {
            const status = document.getElementById('admin-supabase-status');
            if (!status) return;
            const client = ensureSupabaseClient();
            if (!client) {
                status.textContent = 'Supabase не настроен.';
                return;
            }
            const { data } = await client.auth.getSession();
            status.textContent = data?.session ? 'Supabase: вход выполнен.' : 'Supabase: вход не выполнен.';
        }

        function hasAdminPassword() {
            return !!localStorage.getItem(STORAGE_ADMIN_HASH_KEY);
        }

        async function hashPassword(value) {
            const enc = new TextEncoder().encode(value);
            const hash = await crypto.subtle.digest('SHA-256', enc);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function openAdminModal() {
            const modal = document.getElementById('admin-modal');
            const error = document.getElementById('admin-error');
            const input = document.getElementById('admin-password');
            const emailInput = document.getElementById('admin-email');
            const confirmLabel = document.getElementById('admin-password-confirm-label');
            const confirmInput = document.getElementById('admin-password-confirm');
            const title = document.getElementById('admin-title');
            const note = document.getElementById('admin-note');
            if (!modal || !input) return;
            if (error) error.textContent = '';
            input.value = '';
            if (confirmInput) confirmInput.value = '';
            if (emailInput) emailInput.value = loadAdminEmail();

            const needsSetup = !hasAdminPassword();
            if (confirmLabel && confirmInput) {
                confirmLabel.style.display = 'none';
                confirmInput.style.display = 'none';
                confirmInput.required = false;
            }
            if (title) title.textContent = 'Вход администратора';
            if (note) note.textContent = needsSetup
                ? `Пароль по умолчанию: ${DEFAULT_ADMIN_PASSWORD}`
                : 'Введите пароль администратора, чтобы открыть режим управления.';

            modal.classList.add('open');
            modal.setAttribute('aria-hidden', 'false');
            setTimeout(() => input.focus(), 30);
        }

        function closeAdminModal() {
            const modal = document.getElementById('admin-modal');
            if (!modal) return;
            modal.classList.remove('open');
            modal.setAttribute('aria-hidden', 'true');
        }

        function persistCurrentData() {
            rawGedText = generateGedcom(data);
            localStorage.setItem(STORAGE_GED_KEY, rawGedText);
            localStorage.setItem(STORAGE_UPDATED_KEY, new Date().toISOString());
        }

        function generateGedcom(src) {
            const lines = [];
            lines.push('0 HEAD');
            lines.push('1 SOUR serbell');
            lines.push('1 GEDC');
            lines.push('2 VERS 5.5.1');
            lines.push('1 CHAR UTF-8');

            const peopleIds = Object.keys(src.people || {}).sort();
            for (const id of peopleIds) {
                const p = src.people[id];
                if (!p) continue;
                lines.push(`0 @${id}@ INDI`);
                if (p.name) lines.push(`1 NAME ${p.name}`);
                if (p.sex) lines.push(`1 SEX ${p.sex}`);
                if (p.birth) {
                    lines.push('1 BIRT');
                    lines.push(`2 DATE ${p.birth}`);
                }
                if (p.death) {
                    lines.push('1 DEAT');
                    lines.push(`2 DATE ${p.death}`);
                }
                (p.FAMS || []).forEach(fid => {
                    if (fid) lines.push(`1 FAMS @${fid}@`);
                });
                (p.FAMC || []).forEach(fid => {
                    if (fid) lines.push(`1 FAMC @${fid}@`);
                });
            }

            const famIds = Object.keys(src.fams || {}).sort();
            for (const id of famIds) {
                const f = src.fams[id];
                if (!f) continue;
                lines.push(`0 @${id}@ FAM`);
                if (f.husb) lines.push(`1 HUSB @${f.husb}@`);
                if (f.wife) lines.push(`1 WIFE @${f.wife}@`);
                if (f.marriage) {
                    lines.push('1 MARR');
                    lines.push(`2 DATE ${f.marriage}`);
                }
                (f.chil || []).forEach(cid => {
                    if (cid) lines.push(`1 CHIL @${cid}@`);
                });
            }

            lines.push('0 TRLR');
            return lines.join('\n');
        }

        function downloadGedcom() {
            const blob = new Blob([rawGedText || generateGedcom(data)], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'family-tree.ged';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function createPersonId() {
            const ids = Object.keys(data.people || {});
            const nums = ids.map(id => parseInt(id.replace(/\D+/g, ''), 10)).filter(n => !Number.isNaN(n));
            const next = nums.length ? Math.max(...nums) + 1 : 1;
            return `I${next}`;
        }

        function createFamilyId() {
            const ids = Object.keys(data.fams || {});
            const nums = ids.map(id => parseInt(id.replace(/\D+/g, ''), 10)).filter(n => !Number.isNaN(n));
            const next = nums.length ? Math.max(...nums) + 1 : 1;
            return `F${next}`;
        }

        function ensureFamilyForPerson(personId) {
            const p = data.people[personId];
            const famId = (p.FAMS || [])[0];
            if (famId && data.fams[famId]) return data.fams[famId];
            const newId = createFamilyId();
            data.fams[newId] = { id: newId, husb: null, wife: null, chil: [], marriage: '' };
            if (!p.FAMS) p.FAMS = [];
            p.FAMS.push(newId);
            return data.fams[newId];
        }

        function ensureParentFamilyForPerson(personId) {
            const p = data.people[personId];
            const famId = (p.FAMC || [])[0];
            if (famId && data.fams[famId]) return data.fams[famId];
            const newId = createFamilyId();
            data.fams[newId] = { id: newId, husb: null, wife: null, chil: [personId], marriage: '' };
            if (!p.FAMC) p.FAMC = [];
            p.FAMC.push(newId);
            return data.fams[newId];
        }

        function addRelative(basePersonId, { relation, name, sex, birth, death }) {
            const newId = createPersonId();
            data.people[newId] = {
                id: newId,
                name: name || 'Без имени',
                sex: sex || '',
                birth: birth || '',
                death: death || '',
                FAMS: [],
                FAMC: []
            };

            if (relation === 'child') {
                const fam = ensureFamilyForPerson(basePersonId);
                fam.chil = fam.chil || [];
                fam.chil.push(newId);
                data.people[newId].FAMC.push(fam.id);
            } else if (relation === 'spouse') {
                const fam = ensureFamilyForPerson(basePersonId);
                const base = data.people[basePersonId];
                if (sex === 'M') fam.husb = newId;
                else if (sex === 'F') fam.wife = newId;
                else if (!fam.husb) fam.husb = newId;
                else if (!fam.wife) fam.wife = newId;
                if (base.sex === 'M' && !fam.husb) fam.husb = basePersonId;
                if (base.sex === 'F' && !fam.wife) fam.wife = basePersonId;
                data.people[newId].FAMS.push(fam.id);
            } else if (relation === 'parent') {
                const fam = ensureParentFamilyForPerson(basePersonId);
                if (sex === 'M' && !fam.husb) fam.husb = newId;
                else if (sex === 'F' && !fam.wife) fam.wife = newId;
                else if (!fam.husb) fam.husb = newId;
                else if (!fam.wife) fam.wife = newId;
                data.people[newId].FAMS.push(fam.id);
            } else if (relation === 'sibling') {
                const fam = ensureParentFamilyForPerson(basePersonId);
                fam.chil = fam.chil || [];
                fam.chil.push(newId);
                data.people[newId].FAMC.push(fam.id);
            }

            persistCurrentData();
            rootId = findRoot();
            return newId;
        }

        function deletePerson(personId) {
            const p = data.people[personId];
            if (!p) return;
            delete data.people[personId];
            void deleteAllMediaForPerson(personId);
            void deletePersonInfo(personId);

            Object.values(data.fams || {}).forEach(fam => {
                if (fam.husb === personId) fam.husb = null;
                if (fam.wife === personId) fam.wife = null;
                if (Array.isArray(fam.chil)) {
                    fam.chil = fam.chil.filter(cid => cid !== personId);
                }
            });

            Object.values(data.people || {}).forEach(person => {
                person.FAMS = (person.FAMS || []).filter(fid => data.fams[fid]);
                person.FAMC = (person.FAMC || []).filter(fid => data.fams[fid]);
            });

            Object.keys(data.fams || {}).forEach(fid => {
                const fam = data.fams[fid];
                const hasMembers = fam.husb || fam.wife || (fam.chil && fam.chil.length);
                if (!hasMembers) delete data.fams[fid];
            });

            persistCurrentData();
            cleanupMediaMap();
            cleanupInfoMap();
            rootId = findRoot();
        }

        function bindAdminHandlers(person) {
            if (!isAdmin) return;

            const upload = document.getElementById('admin-upload-ged');
            if (upload) {
                upload.onchange = (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        const text = String(reader.result || '');
                        applyGedText(text, { persist: true });
                        render(true);
                        updateInfoUI();
                    };
                    reader.readAsText(file);
                    upload.value = '';
                };
            }

            const resetButton = document.getElementById('admin-reset-ged');
            if (resetButton) {
                resetButton.onclick = async () => {
                    localStorage.removeItem(STORAGE_GED_KEY);
                    localStorage.removeItem(STORAGE_UPDATED_KEY);
                    const fresh = await fetch('./3.ged').then(r => r.text());
                    applyGedText(fresh);
                    render(true);
                    updateInfoUI();
                };
            }

            const exportButton = document.getElementById('admin-export-ged');
            if (exportButton) {
                exportButton.onclick = () => {
                    persistCurrentData();
                    downloadGedcom();
                };
            }

            const saveButton = document.getElementById('admin-save-ged');
            if (saveButton) {
                saveButton.onclick = () => {
                    persistCurrentData();
                    updateInfoUI();
                };
            }

            const logoutButton = document.getElementById('admin-logout');
            if (logoutButton) {
                logoutButton.onclick = () => setAdminState(false);
            }

            const form = document.getElementById('admin-edit-form');
            if (form && person) {
                form.onsubmit = async (e) => {
                    e.preventDefault();
                    const name = document.getElementById('admin-name')?.value.trim() || '';
                    const sex = document.getElementById('admin-sex')?.value || '';
                    const birth = normalizeDateInput(document.getElementById('admin-birth')?.value);
                    const death = normalizeDateInput(document.getElementById('admin-death')?.value);
                    const notes = document.getElementById('admin-info-editor')?.innerHTML || '';

                    person.name = name;
                    person.sex = sex;
                    person.birth = birth;
                    person.death = death;
                    setPersonInfo(person.id, notes);
                    await upsertPersonInfo(person.id, notes);

                    persistCurrentData();
                    render(false);
                    updateInfoUI();
                };
            }

            const resetFields = document.getElementById('admin-reset-fields');
            if (resetFields && person) {
                resetFields.onclick = () => {
                    const name = document.getElementById('admin-name');
                    const sex = document.getElementById('admin-sex');
                    const birth = document.getElementById('admin-birth');
                    const death = document.getElementById('admin-death');
                    if (name) name.value = person.name || '';
                    if (sex) sex.value = person.sex || '';
                    if (birth) birth.value = toInputDate(person.birth || '');
                    if (death) death.value = toInputDate(person.death || '');
                    const editor = document.getElementById('admin-info-editor');
                    if (editor) editor.innerHTML = getPersonInfo(person.id);
                };
            }

            const mediaInput = document.getElementById('admin-media');
            if (mediaInput && person) {
                mediaInput.onchange = async (e) => {
                    const files = Array.from(e.target.files || []);
                    if (!files.length) return;
                    await uploadMediaFiles(person.id, files);
                    mediaInput.value = '';
                };
            }

            document.querySelectorAll('.media-remove').forEach(btn => {
                btn.addEventListener('click', () => {
                    const mediaId = btn.getAttribute('data-media-id');
                    if (!mediaId || !person) return;
                    void deleteMediaEntry(person.id, mediaId);
                });
            });

            const addRelativeForm = document.getElementById('admin-add-relative');
            if (addRelativeForm && person) {
                addRelativeForm.onsubmit = (e) => {
                    e.preventDefault();
                    const relation = document.getElementById('admin-relation')?.value || 'child';
                    const name = document.getElementById('admin-new-name')?.value.trim() || '';
                    const sex = document.getElementById('admin-new-sex')?.value || '';
                    const birth = normalizeDateInput(document.getElementById('admin-new-birth')?.value);
                    const death = normalizeDateInput(document.getElementById('admin-new-death')?.value);

                    const newId = addRelative(person.id, { relation, name, sex, birth, death });
                    currentId = newId;
                    render(true);
                    updateInfoUI();
                    addRelativeForm.reset();
                };
            }

            const supabaseForm = document.getElementById('admin-supabase');
            if (supabaseForm) {
                supabaseForm.onsubmit = async (e) => {
                    e.preventDefault();
                    const url = document.getElementById('admin-supabase-url')?.value.trim() || '';
                    const anonKey = document.getElementById('admin-supabase-key')?.value.trim() || '';
                    const bucket = document.getElementById('admin-supabase-bucket')?.value.trim() || 'person-media';
                    const status = document.getElementById('admin-supabase-status');
                    if (!url || !anonKey) {
                        if (status) status.textContent = 'Заполните SUPABASE_URL и SUPABASE_ANON_KEY.';
                        return;
                    }
                    persistSupabaseConfig({ url, anonKey, bucket });
                    supabaseClient = initSupabaseClient();
                    if (!supabaseClient) {
                        if (status) status.textContent = 'Не удалось инициализировать Supabase клиент.';
                        return;
                    }
                    const [{ error: mediaError }, { error: infoError }] = await Promise.all([
                        supabaseClient.from('person_media').select('id').limit(1),
                        supabaseClient.from('person_info').select('person_id').limit(1)
                    ]);
                    if (mediaError || infoError) {
                        const message = mediaError?.message || infoError?.message || 'Ошибка доступа к таблицам.';
                        if (status) status.textContent = `Ошибка Supabase: ${message}`;
                        return;
                    }
                    if (status) status.textContent = 'Supabase подключен.';
                    updateInfoUI();
                    if (currentId) {
                        void refreshPersonMedia(currentId);
                        void refreshPersonInfo(currentId);
                    }
                };
            }

            const supabaseLogin = document.getElementById('admin-supabase-login');
            if (supabaseLogin) {
                supabaseLogin.onclick = async () => {
                    const status = document.getElementById('admin-supabase-status');
                    const client = ensureSupabaseClient();
                    if (!client) {
                        if (status) status.textContent = 'Сначала сохраните Supabase URL и ключ.';
                        return;
                    }
                    const { error } = await client.auth.signInWithOAuth({
                        provider: 'google',
                        options: { redirectTo: window.location.href }
                    });
                    if (error) {
                        if (status) status.textContent = `Ошибка входа: ${error.message}`;
                        return;
                    }
                    if (status) status.textContent = 'Ожидание входа через Google...';
                };
            }

            void updateSupabaseStatus();


            const deleteButton = document.getElementById('admin-delete-person');
            if (deleteButton && person) {
                deleteButton.onclick = () => {
                    if (!confirm('Удалить выбранного человека?')) return;
                    const wasCurrent = person.id === currentId;
                    deletePerson(person.id);
                    if (wasCurrent) currentId = null;
                    render(true);
                    updateInfoUI();
                };
            }

            const toolbar = document.querySelector('.rich-toolbar');
            if (toolbar) {
                toolbar.querySelectorAll('button[data-command]').forEach(btn => {
                    btn.onclick = () => {
                        const cmd = btn.getAttribute('data-command');
                        if (cmd) document.execCommand(cmd, false, null);
                    };
                });
            }
        }

        /* ================= RENDER ================= */
        function render(doFit) {
            const container = document.getElementById('tree');
            const nw = container.clientWidth;
            const nh = container.clientHeight;
            if (nw !== w || nh !== h) {
                w = nw; h = nh;
                svg.attr('width', w).attr('height', h);
            }

            const baseData = buildDisplayTree(rootId);

            const fullRoot = d3.hierarchy(baseData);
            layout(fullRoot);

            const highlightCandidate = focusResolvedId || currentId;

            let branchIds = new Set();
            let siblingSet = new Set();
            if (highlightCandidate) {
                const resolved = resolveFocusTarget(fullRoot, highlightCandidate);
                setBranchColorFromId(resolved);
                branchIds = computeBranchIds(fullRoot, resolved);

                siblingSet = new Set(getSiblingIds(resolved));
                branchIds = expandIdsWithSiblingsFlat(branchIds, resolved);
            }

            let renderData = baseData;
            if (focusResolvedId && branchIds.size) {
                renderData = pruneDataByIds(baseData, branchIds, siblingSet) || baseData;
            }

            const root = d3.hierarchy(renderData);
            layout(root);
            lastRenderedRoot = root;

            const nodeKey = (d) => {
                const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : '';
                return `${d.data.type}:${pid}`;
            };

            const linkGen = d3.linkHorizontal().x(p => p.y).y(p => p.x);
            const links = root.links();

            function linkKey(l) {
                const a = (l.source.data.type === 'couple') ? l.source.data.primaryId : l.source.data.id;
                const b = (l.target.data.type === 'couple') ? l.target.data.primaryId : l.target.data.id;
                return `${a}=>${b}`;
            }

            const linkSel = g.selectAll('path.link').data(links, linkKey);
            linkSel.exit().transition().duration(ANIM_MS).style('opacity', 0).remove();

            const linkEnter = linkSel.enter()
                .append('path')
                .attr('class', 'link')
                .style('opacity', 0)
                .attr('d', l => linkGen({
                    source: getLinkSourceAnchor(l.source),
                    target: getLinkTargetAnchor(l.target)
                }));

            const linkMerge = linkEnter.merge(linkSel);

            const nodes = root.descendants();
            const nodeSel = g.selectAll('g.node').data(nodes, nodeKey);

            nodeSel.exit().transition().duration(ANIM_MS).style('opacity', 0).remove();

            const nodeEnter = nodeSel.enter()
                .append('g')
                .attr('class', d => `node ${d.data.type}`)
                .style('opacity', 0)
                .attr('transform', d => `translate(${d.y},${d.x})`)
                .each(function (d) {
                    drawNode(d3.select(this), d.data, fullRoot);
                });

            const nodeMerge = nodeEnter.merge(nodeSel);

            nodeMerge.each(function (d) {
                const sel = d3.select(this);
                sel.selectAll('*').remove();
                drawNode(sel, d.data, fullRoot);
            });

            nodeMerge.classed('dimmed', false).classed('in-branch', false);
            linkMerge.classed('dimmed-link', false).classed('in-branch-link', false);

            if (!focusResolvedId && branchIds.size) {
                nodeMerge.each(function (d) {
                    const pid = (d.data.type === 'couple') ? d.data.primaryId : (d.data.type === 'person') ? d.data.id : null;
                    if (pid && !branchIds.has(pid)) d3.select(this).classed('dimmed', true);
                    else d3.select(this).classed('in-branch', true);
                });

                linkMerge.each(function (l) {
                    const a = (l.source.data.type === 'couple') ? l.source.data.primaryId : l.source.data.id;
                    const b = (l.target.data.type === 'couple') ? l.target.data.primaryId : l.target.data.id;
                    if (!(branchIds.has(a) && branchIds.has(b))) d3.select(this).classed('dimmed-link', true);
                    else d3.select(this).classed('in-branch-link', true);
                });
            } else if (focusResolvedId) {
                nodeMerge.classed('in-branch', true);
                linkMerge.classed('in-branch-link', true);
            }

            nodeMerge.transition()
                .duration(ANIM_MS)
                .ease(d3.easeCubicInOut)
                .style('opacity', 1)
                .attr('transform', d => `translate(${d.y},${d.x})`);

            linkMerge.transition()
                .duration(ANIM_MS)
                .ease(d3.easeCubicInOut)
                .style('opacity', 1)
                .attr('d', l => linkGen({
                    source: getLinkSourceAnchor(l.source),
                    target: getLinkTargetAnchor(l.target)
                }));

            if (doFit) fitToContent();
            // иначе сохраняем текущий zoom/позицию (не центрируем автоматически)
        }

        function fitToContent() {
            const b = g.node().getBBox();
            if (!b.width || !b.height) return;

            const pad = 120;
            const s = Math.min(0.95, (w - pad) / b.width, (h - pad) / b.height);
            const tx = w / 2 - (b.x + b.width / 2) * s;
            const ty = h / 2 - (b.y + b.height / 2) * s;

            const target = d3.zoomIdentity.translate(tx, ty).scale(s);

            svg.transition()
                .duration(700)
                .ease(d3.easeCubicInOut)
                .call(zoom.transform, target);
        }

        /* ================= UI ================= */
        function setupUI() {
            document.getElementById('zoom-in').onclick = () => svg.transition().duration(250).call(zoom.scaleBy, 1.2);
            document.getElementById('zoom-out').onclick = () => svg.transition().duration(250).call(zoom.scaleBy, 0.85);

            document.getElementById('reset-view').onclick = () => {
                focusRawId = null;
                focusResolvedId = null;
                render(true);
            };

            document.getElementById('info-tab').onclick = () => togglePanel();
            document.getElementById('toggle-info').onclick = (e) => { e.stopPropagation(); togglePanel(); };

            const adminBtn = document.getElementById('admin-toggle');
            if (adminBtn) {
                adminBtn.onclick = () => {
                    if (isAdmin) {
                        setAdminState(false);
                    } else {
                        openAdminModal();
                    }
                };
            }

            const adminModal = document.getElementById('admin-modal');
            const adminForm = document.getElementById('admin-login-form');
            const adminCancel = document.getElementById('admin-cancel');
            const adminError = document.getElementById('admin-error');
            if (adminForm) {
                adminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const emailInput = document.getElementById('admin-email');
                    const input = document.getElementById('admin-password');
                    const confirmInput = document.getElementById('admin-password-confirm');
                    const needsSetup = !hasAdminPassword();
                    const emailValue = emailInput?.value.trim() || '';
                    if (!emailValue) {
                        if (adminError) adminError.textContent = 'Введите почту.';
                        return;
                    }
                    persistAdminEmail(emailValue);
                    const value = input?.value || '';
                    if (!value || value.length < 6) {
                        if (adminError) adminError.textContent = 'Пароль должен быть минимум 6 символов.';
                        return;
                    }

                    if (value === DEFAULT_ADMIN_PASSWORD) {
                        const hash = await hashPassword(value);
                        localStorage.setItem(STORAGE_ADMIN_HASH_KEY, hash);
                        setAdminState(true);
                        closeAdminModal();
                        return;
                    }

                    const storedHash = localStorage.getItem(STORAGE_ADMIN_HASH_KEY);
                    const hash = await hashPassword(value);
                    if (storedHash && storedHash === hash) {
                        setAdminState(true);
                        closeAdminModal();
                        return;
                    }
                    if (needsSetup && confirmInput?.value && value === confirmInput.value) {
                        localStorage.setItem(STORAGE_ADMIN_HASH_KEY, hash);
                        setAdminState(true);
                        closeAdminModal();
                        return;
                    }
                    if (adminError) adminError.textContent = 'Неверный пароль.';
                });
            }
            if (adminCancel) {
                adminCancel.onclick = () => closeAdminModal();
            }
            if (adminModal) {
                adminModal.addEventListener('click', (e) => {
                    if (e.target === adminModal) closeAdminModal();
                });
            }

            const scrim = document.getElementById('sheet-scrim');
            if (scrim) scrim.onclick = () => { if (isPortrait()) setSheetState('collapsed'); };

            document.getElementById('info-header').onclick = () => {
                if (isPortrait()) togglePanel();
            };

            // Mobile: drag the sheet by grabbing the header
            (() => {
                const header = document.getElementById('info-header');
                const panel = document.getElementById('info-panel');
                if (!header || !panel) return;

                let dragging = false;
                let startY = 0;
                let startTranslate = 0;

                const getPanelTranslateY = () => {
                    const tr = getComputedStyle(panel).transform;
                    if (!tr || tr === 'none') return 0;
                    const m = tr.match(/matrix\(([^)]+)\)/);
                    if (!m) return 0;
                    const parts = m[1].split(',').map(s => parseFloat(s.trim()));
                    // matrix(a,b,c,d,tx,ty)
                    return parts.length >= 6 ? parts[5] : 0;
                };

                const snapToNearest = (currentY) => {
                    syncSheetMetrics(); // use computed vars
                    const peek = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sheet-peek')) || 56;
                    const half = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sheet-half')) || (window.innerHeight * 0.55);
                    const panelH = panel.getBoundingClientRect().height;

                    const yCollapsed = panelH - peek;
                    const yHalf = panelH - half;

                    // mid-point decision
                    const mid = (yCollapsed + yHalf) / 2;
                    const target = (currentY > mid) ? 'collapsed' : 'half';
                    panel.style.transform = '';
                    panel.classList.remove('dragging');
                    setSheetState(target);
                };

                header.addEventListener('pointerdown', (e) => {
                    if (!isPortrait()) return;
                    dragging = true;
                    header.setPointerCapture(e.pointerId);
                    startY = e.clientY;
                    startTranslate = getPanelTranslateY();
                    panel.classList.add('dragging');
                });

                header.addEventListener('pointermove', (e) => {
                    if (!dragging || !isPortrait()) return;

                    const dy = e.clientY - startY;
                    syncSheetMetrics(); // ensure vars are fresh
                    const peek = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sheet-peek')) || 56;
                    const half = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sheet-half')) || (window.innerHeight * 0.55);
                    const panelH = panel.getBoundingClientRect().height;

                    const yCollapsed = panelH - peek;
                    const yHalf = panelH - half;

                    let nextY = startTranslate + dy;
                    nextY = Math.max(yHalf, Math.min(yCollapsed, nextY));

                    panel.style.transform = `translateY(${nextY}px)`;
                });

                const endDrag = (e) => {
                    if (!dragging) return;
                    dragging = false;
                    try { header.releasePointerCapture(e.pointerId); } catch { }
                    const curY = getPanelTranslateY();
                    snapToNearest(curY);
                };

                header.addEventListener('pointerup', endDrag);
                header.addEventListener('pointercancel', endDrag);
            })();


            window.addEventListener('resize', () => {
                render(false);
                updateInfoUI();
                syncSheetMetricsLater();
            });

            window.matchMedia('(max-aspect-ratio: 1/1)').addEventListener('change', () => {
                updateInfoUI();
                syncSheetMetricsLater();
                if (isPortrait()) setSheetState('collapsed');
                // Не панорамируем дерево автоматически при смене состояния панели
            });

            updatePanelArrows();
            syncSheetMetricsLater();
            if (isPortrait()) setSheetState('collapsed');
        }

        function onPersonClick(clickedId, fullRoot) {
            selectPerson(clickedId, false);

            const resolved = resolveFocusTarget(fullRoot, clickedId);

            if (focusRawId === clickedId) {
                focusRawId = null;
                focusResolvedId = null;
            } else {
                focusRawId = clickedId;
                focusResolvedId = resolved;
            }

            render(false);
        }
    </script>
</body>

</html>
